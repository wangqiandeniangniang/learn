## 1 什么是无锁编程
通常意义的无锁编程，指的是没有mutex的编程， 也称为lock，广泛来说，无锁指的描述代码的属性，而不是指代码具体是
如何编写的。
无锁编程的条件：
- 程序使用多线程，或中断、信号处理等
- 多线程访问共享内存
- 线程相互之间不会阻塞，
所以无锁中的锁，指的不仅是mutex， 而是任何可能造成线程阻塞的情况，包括死锁
````
  while(x == 0){
    x = 1-x
  }
````
## 2、无锁的技巧

原子操作、内存屏障（创建硬件内存屏障fence, 以防止CPU重新排序读取和写入操作，它还可能阻止编译器重新排序读写操作），避免ABA问题
- 原子读改写操作
Read-modify-write(RMW)操作则将这种原子操作更加延伸的一部，允许你完成更加复杂的原子的transaction，当一个无锁算法需要支持多个写入器的时候，
这种操作尤为有用，因为多个线程对同一个地址进行RMW操作时，可以将这些线程排入义工执行队列，而后一个个执行性。
- 比较交换循环（Compare-And-Swap Loops）

- 顺序一致性
 
 顺序一致性意味着所有的线程都是遵循内存操作出现的顺序，并且这个顺序与程序源代码中的执行顺序是一致的，在顺序一致性下，不可能存在
 内存重排序的问题，禁止编译器优化，在Java中，你可以标记共享的变量为volatile， 编译器会在后台加入额外的指令， 通常是通过
 内存屏障（memory fence)或RMW操作。这鞋额外的指令可能会使得你的实现丢失一些效率
 
- 内存重排
保证正确的内存执行顺序的工具通常分为三类
    - 轻量级的sync或者屏障指令
    - 完全的内存屏障指令
    - 提供acquire或release语义的内存操作
以上三种避免编译器重排以及处理器重排。