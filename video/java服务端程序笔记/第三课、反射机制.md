## 1、设计模式
### 1.1、设计模式的不同侧重点
- 侧重总体架构的设计模式 如MVC（Java web 开发），MVVM（WPF）
- 侧重细节架构的设计模式，如GOf所描述的23种设计模式
- 侧重实现的模式， 如生产消费队列的同步问题等等

### 1.2、OO设计的主要目的在于封装
- 对直接使用者来说，应该成为一个黑盒子，只要给定输入，就能获取期望的输出
- 对于期望修改行为的使用者来说，应该不需要关注过多的内部实现，更不需要改动内部的代码来
达到修改软件行为的目的
- 实际的做法其实多种多样，核心的设计，在于控制反转（Inversion of Control 或IOC）

### 1.3、Flyweight模式
- 在编程中，有时候发现创建了大量的同类对象
- 对象的创建在java中是比较耗时的，同时这些对象的回收也会占用较多的资源
    - Java中的对象都是创建在heap上的，这种创建方式决定了内存的分配会比
    stack上更加耗时
    - Java的垃圾回收机制，会使得整个程序的执行停顿，过于频繁的垃圾回收会对整个程序的响应速度造成
    严重的影响
    - 尽管在设计及开发前期阶段，过多的考虑性能优惠的方式并不实际也是没有必要的，但是在设计时的一些考虑还是可以
    比较有效的提供程序的运行速度。
### 1.4、 Command模式
- 它尝试以物件来代表实际行动，命令物件可以把行为（action）及其参数封装起来，于是这些行动可以被：
重复多次、取消、取消后重做。
- command模式主要意义在于：
    - 将复杂的操作分解，简化了每一个操作的功能，达到了解耦的目的
    - 通过将多个command组合，可以实现复杂的操作，实现command的复用
    - 能够支持command的取消以及重做。
### 1.5、Java的反射机制
- 允许以类名字符串创建对象
    - JDBC驱动中的Class.forName(驱动类型名)就是一个最常见的例子
- 允许选择对象的狗展示创建对象
- 允许通过方法的字符串名称以及参数类型调用方法
- 允许通过属性的字符串名称存取属性的值

### 1.6、Annotation
- Java支持对接口类、方法、属性上加上Annotation
- 每一个annotation可以定义自己的属性，例如序列号、属性是否必须存在等等
- 因此可以通过annotation，将数据对象的属性进行标注
- 在解码时，获取需要的属性，根据不同的属性类型进行解码，通过反射设置属性值
### 1.7、责任链模式
- 由一系列的command对象组成，在进行处理时，按照command对象的顺序逐步处理
- 可以根据command对象的执行情况决定终止执行或继续执行
- Command模式决定了当执行一个command的时候，只能够完成一个小任务，但是当需要
完成一系列任务时，需要使用责任链模式
- 典型的责任链模式
    - Java Servlet的Filter， 包括前处理Filter或后处理Filter，可以根据Filter的返回
    结果决定是否继续执行，例如通过添加权限处理的Filter，过滤对权限以外的页面或操作的请求
    - MFC的消息处理模式，每个窗体对传来的消息进行处理，消息处理结束后，可根据处理结果继续
    处理或终止处理
    - Netty的channel处理，使用类似Sevlet filter 的方式，只是更加巧妙